---
author: Michał Żygowski
layout: post
title: "1-Wire read data protocol on DHT22 sensor"
date: 2017-08-1 14:14:55 +0200
comments: true
categories: sensors measurements DHT22 1-Wire mbed
---

Recently I have encountered with temperature and humidity measurements using DHT22 sensor. I was developing a driver source code in ARM mbed OS SDK on particular STM32 NUCLEO L432KC platform. Thorough analysis of DHT22 [documentation](https://cdn-shop.adafruit.com/datasheets/Digital+humidity+and+temperature+sensor+AM2302.pdf) led me to the following questions:

- Is it possible to accurately measure voltage-level durations during read process?
- What duration time values should be considered as timeout or/and error?
- Should I weaken the time restrictions in order to avoid random delays in voltage level transitions be considered as failure?

For ARM mbed OS documentation please refer to [mbed API documentation](https://developer.mbed.org/users/screamer/code/mbed/docs/tip/)

### Configuration

Let's start with a little bit of configuration and statistics.

The STM32 NUCLEO L432KC is cocked with up to 80MHz frequency which gives a period of 125 nanoseconds, so basically 8 periods sums to 1 microsecond.

The 1-Wire pin is configured as an `DigitalInOut`, it is necessary to operate both directions, due to communication protocol defined in DHT22 datasheet. Also a timer is enabled to measure voltage level duration.

The DHT22 sensor is connected as proposed in section 5 of DHT22 [documentation](https://cdn-shop.adafruit.com/datasheets/Digital+humidity+and+temperature+sensor+AM2302.pdf), but I used a 4.7kOhm pull-up resistor between data line and VDD, because 10kOhm resistor was producing to much noise. I also added a 100nF capacitor between GND and VDD for wave filtering.


### Read process

Each read operation can be divided into main 2 steps:
1. Host start signal and sensor response
2. Pure data transfer

#### Start signal and sensor response

Initially the data line should be in high state (high voltage), in this particular case it is 3.3V. High state on the data line is considered as idle. To begin transmission the host must pull the data line down for at least 1 milisecond, it is called a start signal. Then host should pull it up and wait for sensor response.
The response should be acquired after 20-40 microseconds.

Procedure described above can be basically carried out like that:

```c
/* Define the data line pin first and a timer*/
DigitalInOut dht_data(DATA_PIN);
Timer timer;

dht_data.output();	//sets the pin in output mode
dht_data.write(0);
wait_ms(2);
tmr.reset();
dht_data.write(1);
tmr.start();
```
**Important** Notice that timer's state is set to 0 before the line is pulled up and then started.

Now is the time for sensor's response. After 20-40 microseconds the sensor should pull the line down for 80 microseconds and then pull it up again for 80 microseconds. To detect it, a do-while loop can be used:

```c

do {
    n = timer.read_us();
    if(n > TIMEOUT) {
        timer.stop();
        return DHT_RESPONSE_TIMEOUT;
    }
    // measure the voltage level duration as long 
    // as data line's state does not change
} while(dht_data.read() == 1);

// reset the timer as soon as data line changes state
// to ensure continuity and validity of voltage level measurement 
timer.reset();
// check
if((n < 20) || (n > 40)) {
    tmr.stop();
    return DHT_RESPONSE_ERROR;
}

do {
    n = tmr.read_us();
    if(n > TIMEOUT) {
        tmr.stop();
        return DHT_RESPONSE_TIMEOUT;
    }
} while(dht_data.read() == 0);

tmr.reset();
if(n != 80) {
    tmr.stop();
    return DHT_RESPONSE_ERROR;
}

do {
    n = tmr.read_us();
    if(n > TIMEOUT) {
        tmr.stop();
        return DHT_RESPONSE_TIMEOUT;
    }
} while(dht_data.read() == 1);

tmr.reset();
if(n != 80) {
    tmr.stop();
    return DHT_RESPONSE_ERROR;
}
```
At this point we can deliberate about the `TIMEOUT` value and the time restrictions provided in the `if` expressions. 100 microseconds seemst t be reasonable value for `TIMEOUT`, beacause there is no voltage level duration longer than 80 microsecond defined by the protocol. 

Running this code will certainly lead to returning `DHT_RESPONSE_ERROR`. Why? The timer restriction provided in `if` expressions are too strict. Tests conducted by me showed, that `timer` does not always read the same amount of microseconds passed each time i ran this code. The values fluctuated between 70 and even 90 microseconds. This dispersion is unacceptable considering 125 nanoseconds clock period in STM32 NUCLEO L432KC. It inspired me to investigate the hardware layer for possible faults. I have used the Saleae Logic Analyzer to monitor the sensor's data line. The result occured to be litttle surprising. The data line waveform I captured is showed below. The sampling frequency was set to 12MHz.

<a class="fancybox" rel="group" href="/assets/images/dht22-response.png"><img src="/assets/images/dht22-response.png" alt="" /></a>

The sensor pulled the line down after c.a. 22 microseconds, which is apropiate. But then the voltage level durations differ slighlty, they are 1.5 microseconds far from 80. In few cases I observed also a 90 microseconds long low voltage level.To confirm the realiability of this measurement I have additionally connected the data line to RIGOL DS1104 oscilloscope. The results were the same as on logic analyzer.

These measurements have been taken with two different wiring lengths. With the shorter wiring, voltage level durations were much more repeatable and closer to the sensor's read protocol. So the time restrictions should be provided as follows:

```c
if((n < 70) || (n > 100)) {
    tmr.stop();
    return DHT_RESPONSE_ERROR;
}
```
#### Data transfer

After sent response, the sensor is transmitting 40 bits of data containing measured temperature, humidity and a checksum. Each bit transfer begins with a 50 microseconds long low voltage level. Then the data line pulls up for 26-28 microseconds or 70 microseconds. The duration of high voltage level determines the bit value:

* 26-68 microseconds - logic '0'
* 70 microseconds - logic '1'

Most significant bit goes first.
Reading and storing entire data can be done like this:

```c
for(int i = 0; i < N_BYTES; i++) {
    for (int b = 0; b < N_BITS; b++) {
        do {
            n = timer.read_us();
            if(n > TIMEOUT) {
                timer.stop();
                return DHT_READ_BIT_TIMEOUT;
            }
        } while(dht_data.read() == 0);

        timer.reset();
        if(n == 50) {
            timer.stop();
            return DHT_READ_BIT_ERROR;
        }

        do {
            n = timer.read_us();
            if(n > TIMEOUT) {
                timer.stop();
                return DHT_READ_BIT_TIMEOUT;
            }
        } while(dht_data.read() == 1);
        timer.reset();

        if((n > 26) && (n < 28)) {
            /* Received '0' */
            buffer[i] <<= 1;
        } else if (n == 70) {
            /* Received '1' */
            buffer[i] = ((buffer[i] << 1) | 1);
        }
    }
}
```
As expected, the time restrictions provided in `if` expressions lead to returning `DHT_READ_BIT_ERROR`. The reason is the same as mentioned previously in [Start signal and sensor response](#start-signal-and-sensor-response). Checking the waveform of data line leads to following results:

<a class="fancybox" rel="group" href="/assets/images/dht22-datatransfer.png"><img src="/assets/images/dht22-datatransfer.png" alt="" /></a>

Picture above shows a fragment of data bits transfer. The voltage level durations are clearly going beyond the acceptable scope. For example, the 64.42 and 73.58 microseconds long voltage level duration are corresponding to logic '1' sent by the sensor, where it should be 50 and 70 microseconds. On the oher hand, next bit sequence is 53.92 nad 73.58 microseconds, which is little bit more accurate, but still far away from sensor's specification. Only logic '0' high voltage duration lasts properly long - 26 microseconds. To ensure reading all bytes without returning an error, I have adjusted the time restrictions in `if` expressions with following values:

```c
if((n < 45) || (n > 70)) {
	timer.stop();
    return DHT_READ_BIT_ERROR;
}

// ...

if((n > 15) && (n < 35)) {
    /* Received '0' */
    buffer[i] <<= 1;
} else if ((n > 65) && (n < 80)) {
    /* Received '1' */
    buffer[i] = ((buffer[i] << 1) | 1);
}

```

>I also have included possible timer inaccuracy to ensure transmission without error returning.

After these changes I was finally able to gather correct measurements repeatedly without failure. To end the transmission, the data line should be pulled up by the host to leave it in an idle state.

```c
tmr.stop();
dht_data.output(); // switch back to output mode
dht_data.write(1);
```

It is also necessary to implement an interval mechanism to prevent polling the sensor sooner than 2 seconds since last poll.


## Summary

Above steps gave me ability to take temperature and humidity measurements by DHT22. This particular sensor has its pros as well as cons.

Its advantage certainly is simplicity in hardware design. Only a pull up resistor, filtering condensator and 3 wire connections are needed.

Its disadvantage is specially designed 1-Wire bus communication. It prevents the usage of common Maxim/Dallas 1-Wire bus standard and forces the developer to implement software driver for handling data reading. Although it is not that difficult, many other problems can occur. As I proved, timing issues are the source of accidental misinterpretation of data and developer confusion.

Better datasheet with acceptable timing deviations ought to be published to avoid problems mentioned by me. It took me a significant amount of time to investigate these issues. Hope that this article will help further developers implementing DHT22 sensors in their projects.
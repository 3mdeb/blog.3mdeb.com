<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: embedded | Linux geek's scratchpad]]></title>
  <link href="http://pietrushnic.github.io/blog/categories/embedded/atom.xml" rel="self"/>
  <link href="http://pietrushnic.github.io/"/>
  <updated>2015-01-26T01:32:55+01:00</updated>
  <id>http://pietrushnic.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ESP-12 update to SDK v0.9.5 and AT v0.21.0.0 - noobs tutorial]]></title>
    <link href="http://pietrushnic.github.io/blog/2015/01/25/esp-12-upgrade-to-esp-iot-sdk-v0-dot-9-5-using-esp-open-sdk-toolchain/"/>
    <updated>2015-01-25T22:32:01+01:00</updated>
    <id>http://pietrushnic.github.io/blog/2015/01/25/esp-12-upgrade-to-esp-iot-sdk-v0-dot-9-5-using-esp-open-sdk-toolchain</id>
    <content type="html"><![CDATA[<p>January 23th Espressif published new ESP IOT SDK on their forum
<a href="http://bbs.espressif.com/viewtopic.php?f=5&amp;t=154">v0.9.5</a>. My ESP-12 came with
with pretty old version so I decide to update it to latest one:</p>

<p>```
AT+RST</p>

<p>OK
y_RSöfJ[úndor:www.ai-thinker.com Version:0.9.2.4]</p>

<p>ready
AT+GMR
0018000902-AI03</p>

<p>OK
```</p>

<h2>ESP-12 firmware update pin configuration</h2>

<p><a class="fancybox" rel="group" href="http://pietrushnic.github.io/assets/images/esp-12-update.jpg"><img src="http://pietrushnic.github.io/assets/images/esp-12-update.jpg" alt="" /></a></p>

<p>As picture presents in addition to normal operation we have to pull down GPIO0
and pull up GPIO2.</p>

<h2>Upgrade using binaries from Espressif</h2>

<p>To upgrade you can use binaries that where delivered in zip packaged and python <a href="">esptool</a>. Run following commands:</p>

<p><code>
git clone git@github.com:themadinventor/esptool.git
wget --content-disposition "http://bbs.espressif.com/download/file.php?id=189"
unzip esp_iot_sdk_v0.9.5_15_01_23.zip
cd esp_iot_sdk_v0.9.5/bin
../../esptool/esptool.py write_flash 0x00000 boot_v1.2.bin 0x01000 at/user1.512.new.bin 0x3e000 blank.bin 0x7e000 blank.bin
</code></p>

<p>First we clone <code>esptool</code> repository, then we get latest SDK release directly
from forum and finally we ran <code>esptool</code>.</p>

<p>If you will get something like this:</p>

<p>```
Connecting&hellip;
Traceback (most recent call last):
  File &ldquo;../../esptool/esptool.py&rdquo;, line 408, in <module></p>

<pre><code>esp.connect()
</code></pre>

<p>  File &ldquo;../../esptool/esptool.py&rdquo;, line 143, in connect</p>

<pre><code>raise Exception('Failed to connect')
</code></pre>

<p>Exception: Failed to connect
```</p>

<p>You can work around this by toggling power to the module right before executing
<code>esptool</code> command. It works on my side.</p>

<p>Successful flashing looks like this:</p>

<p>```
[1:00:21] pietrushnic:bin $ ../../esptool/esptool.py write_flash 0x00000 boot_v1.2.bin 0x01000 at/user1.512.new.bin 0x3e000 blank.bin 0x7e000 blank.bin
Connecting&hellip;
Erasing flash&hellip;
Writing at 0x00000400&hellip; (100 %)
Erasing flash&hellip;
Writing at 0x00034800&hellip; (100 %)
Erasing flash&hellip;
Writing at 0x0003ec00&hellip; (100 %)
Erasing flash&hellip;
Writing at 0x0007ec00&hellip; (100 %)</p>

<p>Leaving&hellip;
```</p>

<p>After disconnecting GPIO0 and GPIO2 you can boot new firmware. Results should
look like this:</p>

<p>```
AT+RST</p>

<p>OK</p>

<p> ets Jan  8 2013,rst cause:4, boot mode:(3,4)</p>

<p>wdt reset
load 0x40100000, len 816, room 16
tail 0
chksum 0x8d
load 0x3ffe8000, len 788, room 8
tail 12
chksum 0xcf
ho 0 tail 12 room 4
load 0x3ffe8314, len 288, room 12
tail 4
chksum 0xcf
csum 0xcf</p>

<p>2nd boot version : 1.2
  SPI Speed      : 40MHz
  SPI Mode       : QIO
  SPI Flash Size : 4Mbit
jump to run user1</p>

<p>rNÿ
ready
AT+GMR
AT version:0.21.0.0
SDK version:0.9.5</p>

<p>OK
```</p>

<p>Of course you will need the toolchain to use new SDK.</p>

<h2>Toolchain</h2>

<p><a href="https://github.com/pfalcon/esp-open-sdk">esp-open-sdk</a> is probably easiest to
use toolchain that I found for ESP8266. <code>esp-open-sdk</code> puts together steps
created by <a href="http://www.esp8266.com/">ESP8266 Community Forum</a> published in
<a href="https://github.com/esp8266/esp8266-wiki/wiki">esp8266-wiki</a> repository.</p>

<p><code>esp-open-sdk</code> at the moment of writing this post didn&rsquo;t support <code>v0.9.5</code> SDK,
but adding this support was pretty straight forward and can be found on my
github for of the <a href="https://github.com/pietrushnic/esp-open-sdk.git">repo</a>.
There is also <a href="https://github.com/pfalcon/esp-open-sdk/pull/18">pending PR</a> that hopefully will be merged.</p>

<p>Procedure is straight forward to follow:</p>

<p><code>
git clone git@github.com:pietrushnic/esp-open-sdk.git #or use https with https://github.com/pietrushnic/esp-open-sdk.git
cd esp-open-sdk
git co v0.9.5-support
sed -i -e '/\s0.9.4/s/^/#/g' -e '/\s0.9.5/s/^#//g' Makefile
make
</code></p>

<p><code>sed</code> command will cause using <code>0.9.5</code> string as <code>VENDOR_SDK</code> for default build.</p>

<p>On my i7-4700 single threaded compilation takes ~20min. BTW I&rsquo;m trying to
figure out why I cannot use multiple jobs
<a href="https://github.com/pfalcon/esp-open-sdk/issues/19">here</a>.</p>

<p>Final message should contain something like:</p>

<p><code>
export PATH=/home/pietrushnic/tmp/esp-open-sdk/xtensa-lx106-elf/bin:$PATH
</code></p>

<p>Just execute this command in your shell. If you missed that message run <code>make</code>
again it should skip all already compiled parts and display final message
again.</p>

<h2>Toolchain usage</h2>

<p>To use toolchain with example code from <code>v0.9.5</code> SDK you can simply:</p>

<p><code>
cd esp_iot_sdk_v0.9.5
</code></p>

<p>Use package like it was presented in &ldquo;Upgrade using binaries from Espressif&rdquo; section. Trying to compile exmaples in <code>esp-open-sdk</code> will give you error like this:</p>

<p><code>
../../Makefile:154: warning: overriding recipe for target 'clean'
../Makefile:258: warning: ignoring old recipe for target 'clean'
You cloned without --recursive, fetching submodules for you.
git submodule update --init --recursive
make -C crosstool-NG -f ../Makefile _ct-ng
make[1]: *** crosstool-NG: No such file or directory.  Stop.
../../Makefile:140: recipe for target 'crosstool-NG/ct-ng' failed
make: *** [crosstool-NG/ct-ng] Error 2
</code></p>

<p>When inside <code>esp_iot_sdk_v0.9.5</code>:</p>

<p><code>
cp -r examples/at .
make COMPILE=gcc
</code></p>

<p>Ommiting <code>COMPILE=gcc</code> will result in error caused by using differen compiler name:</p>

<p><code>
make[1]: Entering directory '/home/pietrushnic/src/espressif/esp_iot_sdk_v0.9.5/at/user'
DEPEND: xt-xcc -M -Os -g -O2 -Wpointer-arith -Wundef -Werror -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals -DICACHE_FLASH -I include -I ./ -I ../../include/ets -I ../include -I ../../include -I ../../include/eagle user_main.c
/bin/sh: 2: xt-xcc: not found
xt-xcc -Os -g -O2 -Wpointer-arith -Wundef -Werror -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals  -DICACHE_FLASH   -I include -I ./ -I ../../include/ets -I ../include -I ../../include -I ../../include/eagle  -o .output/eagle/debug/obj/user_main.o -c user_main.c
make[1]: xt-xcc: Command not found
../../Makefile:280: recipe for target '.output/eagle/debug/obj/user_main.o' failed
make[1]: *** [.output/eagle/debug/obj/user_main.o] Error 127
make[1]: Leaving directory '/home/pietrushnic/src/espressif/esp_iot_sdk_v0.9.5/at/user'
../Makefile:266: recipe for target '.subdirs' failed
make: *** [.subdirs] Error 2
</code></p>

<p>Correct output looks like this:</p>

<p>```
make[1]: Entering directory &lsquo;/home/pietrushnic/src/espressif/esp_iot_sdk_v0.9.5/at/user&rsquo;
DEPEND: xtensa-lx106-elf-gcc -M -Os -g -O2 -Wpointer-arith -Wundef -Werror -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals -DICACHE_FLASH -I include -I ./ -I ../../include/ets -I ../include -I ../../include -I ../../include/eagle user_main.c
xtensa-lx106-elf-gcc -Os -g -O2 -Wpointer-arith -Wundef -Werror -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals  -DICACHE_FLASH   -I include -I ./ -I ../../include/ets -I ../include -I ../../include -I ../../include/eagle  -o .output/eagle/debug/obj/user_main.o -c user_main.c
xtensa-lx106-elf-ar ru .output/eagle/debug/lib/libuser.a .output/eagle/debug/obj/user_main.o
xtensa-lx106-elf-ar: creating .output/eagle/debug/lib/libuser.a
make[1]: Leaving directory &lsquo;/home/pietrushnic/src/espressif/esp_iot_sdk_v0.9.5/at/user&rsquo;
xtensa-lx106-elf-gcc  -L../lib -nostdlib -T../ld/eagle.app.v6.ld -Wl,&mdash;no-check-sections -u call_user_start -Wl,-static -Wl,&mdash;start-group -lc -lgcc -lhal -lphy -lpp -lnet80211 -llwip -lwpa -lmain -ljson -lupgrade user/.output/eagle/debug/lib/libuser.a                                    -lat -Wl,&mdash;end-group -o .output/eagle/debug/image/eagle.app.v6.out</p>

<p>!!!
No boot needed.
Generate eagle.flash.bin and eagle.irom0text.bin successully in folder bin.
eagle.flash.bin&mdash;&mdash;&mdash;&mdash;>0x00000
eagle.irom0text.bin&mdash;&mdash;>0x40000
!!!
```</p>

<p>Now <code>../bin</code> directory contain <code>eagle.flash.bin</code> and <code>eagle.irom0text.bin</code>,
which you can use to flash your ESP8266 using <code>esptool</code>:</p>

<p><code>
../../esptool/esptool.py write_flash 0x00000 eagle.flash.bin 0x40000 eagle.irom0text.bin
</code></p>

<h2>Summary</h2>

<p>Thanks for reading. Hope that this post fill the gap that some of beginner can
experience when goolging through straight forward tutorial about playing with
ESP. If you like this post please share. If you see some bias or you just want
to share some facts, ask question then please leave a comment.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x6: Root file system for embedded system]]></title>
    <link href="http://pietrushnic.github.io/blog/2013/06/07/root-file-system-for-embedded-system/"/>
    <updated>2013-06-07T10:40:00+02:00</updated>
    <id>http://pietrushnic.github.io/blog/2013/06/07/root-file-system-for-embedded-system</id>
    <content type="html"><![CDATA[<h2>Table of contents</h2>

<ul>
<li><a href="/blog/2013/06/07/root-file-system-for-embedded-system/#intro">Introduction</a></li>
<li><a href="/blog/2013/06/07/root-file-system-for-embedded-system/#get-bb">Get and build BusyBox</a></li>
<li><a href="/blog/2013/06/07/root-file-system-for-embedded-system/#fast-and-simple">Fast and simple</a></li>
<li><a href="/blog/2013/06/07/root-file-system-for-embedded-system/#setting-up-kernel-through-nfs">Setting up kernel through NFS</a></li>
<li><a href="/blog/2013/06/07/root-file-system-for-embedded-system/#verify-configuration">Verify Configuration</a></li>
<li><a href="/blog/2013/06/07/root-file-system-for-embedded-system/#embedded-filesystem-tuning">Embedded filesystem tuning</a></li>
<li><a href="/blog/2013/06/07/root-file-system-for-embedded-system/#summary">Summary</a></li>
</ul>


<p><a id="intro"></a></p>

<h3>Introduction</h3>

<p>To make our embedded linux work as virtual development platform we need some
environment after booting. There is many approaches to get working root file
system but I will use the easiest one as an exercise. I don&rsquo;t want to create full
embedded distribution (this is good plan for future works). Right now I will be
happy with simple initramfs based on <a href="http://busybox.net/">BusyBox</a>.</p>

<p>For all interested in creating own root filesystem there are few places where
you can find informations:</p>

<ul>
<li><a href="http://lwn.net/Articles/210046/">Embedded Linux: Small Root Filesystems</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/filesystems/ramfs-rootfs-initramfs.txt">ramfs-rootfs-initramfs</a></li>
<li><a href="http://processors.wiki.ti.com/index.php/Creating_a_Root_File_System_for_Linux_on_OMAP35x">Creating a Root File System for Linux on OMAP35x</a></li>
</ul>


<p><a id="get-bb"></a></p>

<h3>Get and build BusyBox</h3>

<p>Clone git repository:
<code>
git clone git://git.busybox.net/busybox
</code></p>

<p><a id="fast-and-simple"></a></p>

<h3>Fast and simple</h3>

<p>Of course make sure to use correct toolchain. I made few notes about
Ubuntu/Linaro toolchain in <a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#ubuntu-issues">previous post</a>
<code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
</code>
Mark <code>Busybox Settings -&gt; Build Options -&gt; Build BusyBox as a static binary (no
shared libs)</code> option. Exit and save.
<code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- install
cd _install/
</code>
<a id="setting-up-kernel-through-nfs"></a></p>

<h3>Setting up kernel through NFS</h3>

<p><a href="/blog/2013/06/07/linux-kernel-for-embedded-system">Previously</a> we prepared U-Boot
kenernel image with DHCP and rootfs which we want to expose over NFS. First lets start with NFS
configuration:
<code>
sudo apt-get install nfs-kernel-server
</code>
I use simple <code>/etc/exports</code> configuration:
<code>
/srv/homes 192.168.1.0/255.255.255.0(rw,sync,no_subtree_check,no_root_squash)
</code>
Make sure that <code>/srv/homes</code> exist, if no than create it. After editing nfs
configuration file we have to restart NFS server:
<code>
sudo service nfs-kernel-server restart
</code>
<a id="verify-configuration"></a></p>

<h3>Verify configuration</h3>

<p>I assume that you go through all previous articles in this series.
To verify configuration we have to copy whole BusyBox <code>_install</code> directory to
known nfs location:
<code>
mkdir /srv/homes/rootfs
sudo chmod 777 /srv/homes/rootfs
cd /srv/homes/rootfs
cp -R /path/to/busybox/_install/* .
</code>
Now we can try our Virtual Development Board:
<code>
sudo qemu-system-arm -kernel src/u-boot/u-boot -net nic,vlan=0 -net \
tap,vlan=0,ifname=tap0,script=/etc/qemu-ifup -nographic -M versatilepb
</code>
After U-Boot booting:
<code>
VersatilePB # setenv autload no
VersatilePB # dhcp
MC91111: PHY auto-negotiate timed out
SMC91111: MAC 52:54:00:12:34:56
BOOTP broadcast 1
DHCP client bound to address 192.168.1.13
VersatilePB # setenv serverip 192.168.1.24
VersatilePB # setenv bootfile uImage
VersatilePB # tftp
</code>
Note that <code>192.168.1.24</code> should be replaced with correct address of TFTP server.
```
VersatilePB # tftp
SMC91111: PHY auto-negotiate timed out
SMC91111: MAC 52:54:00:12:34:56
Using SMC91111-0 device
TFTP from server 192.168.1.20; our IP address is 192.168.1.13
Filename &lsquo;uImage&rsquo;.
Load address: 0x7fc0
Loading: #################################################################</p>

<pre><code>     #################################################################
     #################################################################
     #################################################################
     #################################################################
     ##################################################
     252 KiB/s
</code></pre>

<p>done
Bytes transferred = 1917944 (1d43f8 hex)
<code>
Right now we will set boot arguments for our kernel:
</code>
setenv bootargs &lsquo;root=/dev/nfs mem=128M ip=dhcp netdev=25,0,0xf1010000,0xf1010010,eth0 nfsroot=192.168.1.20:/srv/homes/rootfs console=ttyAMA0&rsquo;
```
What does it mean:</p>

<ul>
<li><code>root=/dev/nfs</code> &ndash; following
<a href="https://www.kernel.org/doc/Documentation/filesystems/nfs/nfsroot.txt">kernel.org</a>:
<blockquote><p>This is necessary to enable the pseudo-NFS-device. Note that it&rsquo;s not a real device but just a synonym to tell the kernel to use NFS instead of a real device.</p></blockquote></li>
<li><code>mem=128M ip=dhcp</code> &ndash; self-explaining</li>
<li><code>netdev=25,0,0xf1010000,0xf1010010,eth0</code> &ndash; network device configuration
(<code>Format: &lt;irq&gt;,&lt;io&gt;,&lt;mem_start&gt;,&lt;mem_end&gt;,&lt;name&gt;</code>), this was provided by
default <code>U-Boot</code> bootargs</li>
<li><code>nfsroot=192.168.1.20:/srv/homes/rootfs</code> &ndash; NFS server ip and path to rootfs</li>
<li><code>console=ttyAMA0</code> &ndash; very importanat if you want to see anything in <code>-nographic</code> mode</li>
</ul>


<p>After setting bootargs we can boot our Virtual Development Board:
<code>
bootm
</code>
As you can see that&rsquo;s not all, our current configuration end with:
```
(&hellip;)
Sending DHCP requests .input: AT Raw Set 2 keyboard as
/devices/fpga:06/serio0/input/input0
, OK
IP-Config: Got DHCP answer from 192.168.1.1, my address is 192.168.1.13
IP-Config: Complete:</p>

<pre><code> device=eth0, hwaddr=52:54:00:12:34:56, ipaddr=192.168.1.13, mask=255.255.255.0, gw=192.168.1.1
 host=192.168.1.13, domain=, nis-domain=(none)
 bootserver=0.0.0.0, rootserver=192.168.1.20, rootpath=
 nameserver0=192.168.1.1
</code></pre>

<p>input: ImExPS/2 Generic Explorer Mouse as
/devices/fpga:07/serio1/input/input1
VFS: Mounted root (nfs filesystem) on device 0:9.
Freeing unused kernel memory: 112K (c034e000 &ndash; c036a000)
nfs: server 192.168.1.20 not responding, still trying
nfs: server 192.168.1.20 OK
can&rsquo;t run &lsquo;/etc/init.d/rcS&rsquo;: No such file or directory
can&rsquo;t open /dev/tty2: No such file or directory
can&rsquo;t open /dev/tty3: No such file or directory</p>

<p>can&rsquo;t open /dev/tty4: No such file or directory
can&rsquo;t open /dev/tty2: No such file or directory
can&rsquo;t open /dev/tty3: No such file or directory
can&rsquo;t open /dev/tty4: No such file or directory
can&rsquo;t open /dev/tty2: No such file or directory
can&rsquo;t open /dev/tty3: No such file or directory
<code>``
try to open ttys loop. This is because of default behavior of</code>BusyBox<code>when</code>inittab`
was not found.</p>

<p><a id="embedded-filesystem-tuning"></a></p>

<h3>Embedded filesystem tuning</h3>

<p>To override above behavior we have to create <code>/etc/inittab</code> file:
<code>
cd /srv/homes/rootfs
mkdir etc
vim etc/inittab
</code>
Our <code>inittab</code> is very simple:
<code>
::sysinit:/etc/init.d/rcS
::askfirst:/bin/ash
::ctrlaltdel:/sbin/reboot
::shutdown:/sbin/swapoff -a
::shutdown:/bin/umount -a -r
::restart:/sbin/init
</code>
If you want to learn more about inittab &ndash; <code>man inittab</code> .We need improve out filesystem with few directories:
<code>
mkdir sys proc etc/init.d
</code>
In <code>/etc/init.d/rcS</code> we will mount sysfs and procfs:
```bash</p>

<h1>! /bin/sh</h1>

<p>mount -t proc proc /proc
mount -t sysfs sysfs /sys
<code>
Give executable permission to `rcS` script:
</code>
chmod +x etc/init.d/rcS
<code>
We also have to create `dev` directory with `ttyAMA0` block device:
</code>
mkdir dev
sudo mknod dev/ttyAMA0 c 204 64
sudo mknod dev/null c 1 3
sudo mknod dev/console c 5 1
```</p>

<p>Right now we should be able to boot our Virtual Development Board. Let&rsquo;s try
again:

<code>``
pietrushnic@eglarest:~$ sudo qemu-system-arm -m 256M -kernel src/u-boot/u-boot -net nic,vlan=0 -net tap,vlan=0,ifname=tap0,script=/etc/qemu-ifup -nographic -M versatilepb -net dump,file=/tmp/dump.pcap
Executing /etc/qemu-ifup
Bringing up tap0 for bridged mode...
Adding tap0 to br0...
oss: Could not initialize DAC
oss: Failed to open</code>/dev/dsp'
oss: Reason: No such file or directory
oss: Could not initialize DAC
oss: Failed to open <code>/dev/dsp'
oss: Reason: No such file or directory
audio: Failed to create voice</code>lm4549.out'</p>

<p>U-Boot 2013.04-00274-ga71d45d (May 27 2013 &ndash; 17:36:14)</p>

<p>DRAM:  128 MiB
WARNING: Caches not enabled
Flash: 64 MiB
*** Warning &ndash; bad CRC, using default environment</p>

<p>In:    serial
Out:   serial
Err:   serial
Net:   SMC91111-0
Warning: SMC91111-0 using MAC address from net device</p>

<p>VersatilePB # setenv serverip 192.168.1.24
VersatilePB # setenv bootfile uImage
VersatilePB # setenv bootargs &lsquo;root=/dev/nfs mem=128M ip=dhcp netdev=25,0,0xf1010000,0xf1010010,eth0 nfsroot=192.168.1.24:/sv/homes/rootfs console=ttyAMA0&rsquo;
VersatilePB # dhcp
SMC91111: PHY auto-negotiate timed out
SMC91111: MAC 52:54:00:12:34:56
BOOTP broadcast 1
DHCP client bound to address 192.168.1.13
Using SMC91111-0 device
TFTP from server 192.168.1.24; our IP address is 192.168.1.13
Filename &lsquo;uImage&rsquo;.
Load address: 0x7fc0
Loading: *############T #####################################################</p>

<pre><code> #################################################################
 #################################################################
 #################################################################
 #################################################################
 ##################################################
 0 Bytes/s
</code></pre>

<p>done
Bytes transferred = 1917944 (1d43f8 hex)
VersatilePB # bootm</p>

<h2>Booting kernel from Legacy Image at 00007fc0 &hellip;</h2>

<p>   Image Name:   Linux-3.10.0-rc3
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    1917880 Bytes = 1.8 MiB
   Load Address: 00008000
   Entry Point:  00008000
   XIP Kernel Image &hellip; OK
OK</p>

<p>Starting kernel &hellip;</p>

<p>Uncompressing Linux&hellip; done, booting the kernel.
Booting Linux on physical CPU 0x0
Linux version 3.10.0-rc3 (pietrushnic@eglarest) (gcc version 4.7.2 (Debian 4.7.2-4) ) #2 Sun Jun 2 20:25:23 CEST 2013
CPU: ARM926EJ-S [41069265] revision 5 (ARMv5TEJ), cr=00093177
CPU: VIVT data cache, VIVT instruction cache
Machine: ARM-Versatile PB
Memory policy: ECC disabled, Data cache writeback
sched_clock: 32 bits at 24MHz, resolution 41ns, wraps every 178956ms
Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 32512
Kernel command line: root=/dev/nfs mem=128M ip=dhcp netdev=25,0,0xf1010000,0xf1010010,eth0 nfsroot=192.168.1.24:/srv/homes/rootfs console=ttyAMA0
PID hash table entries: 512 (order: -1, 2048 bytes)
Dentry cache hash table entries: 16384 (order: 4, 65536 bytes)
Inode-cache hash table entries: 8192 (order: 3, 32768 bytes)
Memory: 128MB = 128MB total
Memory: 126136k/126136k available, 4936k reserved, 0K highmem
Virtual kernel memory layout:</p>

<pre><code>vector  : 0xffff0000 - 0xffff1000   (   4 kB)
fixmap  : 0xfff00000 - 0xfffe0000   ( 896 kB)
vmalloc : 0xc8800000 - 0xff000000   ( 872 MB)
lowmem  : 0xc0000000 - 0xc8000000   ( 128 MB)
modules : 0xbf000000 - 0xc0000000   (  16 MB)
  .text : 0xc0008000 - 0xc034dd58   (3352 kB)
  .init : 0xc034e000 - 0xc036ae8c   ( 116 kB)
  .data : 0xc036c000 - 0xc0391de0   ( 152 kB)
   .bss : 0xc0391de0 - 0xc03ad6cc   ( 111 kB)
</code></pre>

<p>NR_IRQS:224
VIC @f1140000: id 0x00041190, vendor 0x41
FPGA IRQ chip 0 &ldquo;SIC&rdquo; @ f1003000, 13 irqs
Console: colour dummy device 80x30
Calibrating delay loop&hellip; 649.21 BogoMIPS (lpj=3246080)
pid_max: default: 32768 minimum: 301
Mount-cache hash table entries: 512
CPU: Testing write buffer coherency: ok
Setting up static identity map for 0xc0286e90 &ndash; 0xc0286ee8
NET: Registered protocol family 16
DMA: preallocated 256 KiB pool for atomic coherent allocations
Serial: AMBA PL011 UART driver
dev:f1: ttyAMA0 at MMIO 0x101f1000 (irq = 44) is a PL011 rev1
console [ttyAMA0] enabled
dev:f2: ttyAMA1 at MMIO 0x101f2000 (irq = 45) is a PL011 rev1
dev:f3: ttyAMA2 at MMIO 0x101f3000 (irq = 46) is a PL011 rev1
fpga:09: ttyAMA3 at MMIO 0x10009000 (irq = 70) is a PL011 rev1
bio: create slab &lt;bio-0> at 0
Switching to clocksource timer3
NET: Registered protocol family 2
TCP established hash table entries: 1024 (order: 1, 8192 bytes)
TCP bind hash table entries: 1024 (order: 0, 4096 bytes)
TCP: Hash tables configured (established 1024 bind 1024)
TCP: reno registered
UDP hash table entries: 256 (order: 0, 4096 bytes)
UDP-Lite hash table entries: 256 (order: 0, 4096 bytes)
NET: Registered protocol family 1
RPC: Registered named UNIX socket transport module.
RPC: Registered udp transport module.
RPC: Registered tcp transport module.
RPC: Registered tcp NFSv4.1 backchannel transport module.
NetWinder Floating Point Emulator V0.97 (double precision)
Installing knfsd (copyright &copy; 1996 <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#111;&#x6b;&#105;&#x72;&#64;&#x6d;&#x6f;&#110;&#97;&#x64;&#x2e;&#x73;&#x77;&#98;&#x2e;&#x64;&#101;">&#x6f;&#107;&#x69;&#x72;&#64;&#109;&#111;&#x6e;&#97;&#100;&#x2e;&#115;&#119;&#98;&#46;&#x64;&#101;</a>).
jffs2: version 2.2. (NAND) © 2001-2006 Red Hat, Inc.
ROMFS MTD &copy; 2007 Red Hat, Inc.
msgmni has been set to 246
Block layer SCSI generic (bsg) driver version 0.4 loaded (major 254)
io scheduler noop registered
io scheduler deadline registered
io scheduler cfq registered (default)
clcd-pl11x dev:20: PL110 rev0 at 0x10120000
clcd-pl11x dev:20: Versatile hardware, VGA display
Console: switching to colour frame buffer device 80x60
brd: module loaded
physmap platform flash device: 04000000 at 34000000
physmap-flash.0: Found 1 x32 devices at 0x0 in 32-bit bank. Manufacturer ID 0x000000 Chip ID 0x000000
Intel/Sharp Extended Query Table at 0x0031
Using buffer write method
smc91x.c: v1.1, sep 22 2004 by Nicolas Pitre <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x6e;&#x69;&#x63;&#111;&#64;&#102;&#108;&#x75;&#x78;&#x6e;&#105;&#x63;&#x2e;&#110;&#101;&#x74;">&#110;&#105;&#99;&#x6f;&#64;&#102;&#108;&#117;&#120;&#110;&#105;&#x63;&#46;&#x6e;&#x65;&#116;</a>
eth0: SMC91C11xFD (rev 1) at c89c8000 IRQ 57 [nowait]
eth0: Ethernet addr: 52:54:00:12:34:56
mousedev: PS/2 mouse device common for all mice
TCP: cubic registered
NET: Registered protocol family 17
VFP support v0.3: implementor 41 architecture 1 part 10 variant 9 rev 0
eth0: link up
Sending DHCP requests ., OK
IP-Config: Got DHCP answer from 192.168.1.1, my address is 192.168.1.13
IP-Config: Complete:</p>

<pre><code> device=eth0, hwaddr=52:54:00:12:34:56, ipaddr=192.168.1.13, mask=255.255.255.0, gw=192.168.1.1
 host=192.168.1.13, domain=, nis-domain=(none)
 bootserver=0.0.0.0, rootserver=192.168.1.24, rootpath=
 nameserver0=192.168.1.1
</code></pre>

<p>input: AT Raw Set 2 keyboard as /devices/fpga:06/serio0/input/input0
input: ImExPS/2 Generic Explorer Mouse as /devices/fpga:07/serio1/input/input1
VFS: Mounted root (nfs filesystem) on device 0:9.
Freeing unused kernel memory: 112K (c034e000 &ndash; c036a000)</p>

<p>Please press Enter to activate this console.
/bin/ash: can&rsquo;t access tty; job control turned off
/ #
```
</p>

<p><a id="summary"></a></p>

<h3>Summary</h3>

<p>This setup need few minor tweaks like adding U-Boot environment variables
storage to not enter it every time or removing annoying message <code>can't access
tty(...)</code>. I&rsquo;m done for now, its time to take care about other challenges. I
hope that I will back to this issues in near future. If you like this series
please share it, if somethings wrong please comment I will try to help if can.</p>

<p><a href="http://bec-systems.com/site/418/how-to-set-up-a-nfs-rootfs">How to set up a NFS root filesystem for embedded Linux development</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x5: Qemu network configuration and tftp for Virtual Development Board]]></title>
    <link href="http://pietrushnic.github.io/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/"/>
    <updated>2013-06-07T10:36:00+02:00</updated>
    <id>http://pietrushnic.github.io/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board</id>
    <content type="html"><![CDATA[<h2>Table of contents</h2>

<ul>
<li><a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#intro">Introduction</a></li>
<li><a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#setup-tftpd">Setup tftpd</a></li>
<li><a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#qemu-networking">QEMU networking</a></li>
<li><a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#verify-qemu-with-tftp">Verify all components of Virtual Development Platform</a></li>
<li><a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#what-next">What next ?</a></li>
</ul>


<p><a id="intro"></a></p>

<h3>Introduction</h3>

<p>This was not trivial task to me. As usual <code>google is your friend</code> and <code>RTFM</code> works.
First we will set tftp which we use to download modified kernel for U-Boot.
Second I will show how to setup bridged network for QEMU needs and finally we
will perform some basic test of our setup. Let&rsquo;s go.</p>

<p><a id="setup-tftpd"></a></p>

<h3>Setup tftpd</h3>

<p>First install:
<code>bash
sudo apt-get install tftpd tftp
</code>
Make sure that <code>/srv/tftp</code> is writable for your user. If directory doesn&rsquo;t exist
create it and give needed privileges. If you want to change some server options
edit <code>/etc/inetd.conf</code>. Copy or link our kernel to tftp server
directory.
<code>bash
cd /path/to/kernel/arch/arm/boot
ln -s $PWD/uImage /srv/tftp/uImage
</code>
Verify if everything works correctly:
<code>bash
cd             # go to home or any other directory different than arch/arm/boot
tftp 127.0.0.1 # connect to localhost tftp server
get uImage     # get kernel file
q              # quit tftp
</code>
Check if kernel file is in current directory. If yes than you tftp server is
configured correctly, if not then google or ask me a question in comments
section.
<em>Note</em>: For Ubuntu follow instructions from
<a href="http://www.davidsudjiman.info/2006/03/27/installing-and-setting-tftpd-in-ubuntu/">here</a>.</p>

<p><a id="qemu-networking"></a></p>

<h3>QEMU networking</h3>

<p><em>Update</em>: For Ubuntu users please read <a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#ubuntu-issues">this section</a></p>

<p>I mixed <a href="http://toast.djw.org.uk/qemu.html">this</a> BKM and few other resources
that I found in the net. Setting up network depend a lot on your configuration.
I will briefly describe my situation. It is quite possible that this won&rsquo;t fit
yours.</p>

<p>I&rsquo;ve <code>eth0</code> with ip <code>10.0.2.15</code>. What I want to do is create another interface <code>tap0</code> and
bridge <code>br0</code> that will connect <code>eth0</code> and <code>tap0</code>. To do this I need few things:</p>

<ul>
<li><code>brctl</code> is provided in Debian by <code>bridge-utils</code>
<code>
sudo apt-get install bridge-utils
</code></li>
<li>check if TUN module was installed
<code>
grep CONFIG_TUN= /boot/config-`uname -r`
</code>
you should get <code>y</code> or <code>m</code>, if it is <code>m</code> than <code>modprobe tun</code>:
<code>
sudo modprobe tun
</code></li>
<li>create tun device
<code>
sudo mknod /dev/net/tun c 10 200
</code></li>
<li>update <code>/etc/network/interfaces</code>:
```bash

<h1>This file describes the network interfaces available on your system</h1>

<h1>and how to activate them. For more information, see interfaces(5).</h1></li>
</ul>


<h1>The loopback network interface</h1>

<p>auto lo
iface lo inet loopback</p>

<h1>add br0 configuration</h1>

<p>auto br0
iface br0 inet dhcp
bridge_ports eth0 # do not forget to attach eth0 to br0
bridge_fd 9
bridge_hello 2
bridge_maxage 12
bridge_stp off</p>

<h1>The primary network interface</h1>

<p>allow-hotplug eth0     # comment this
iface eth0 inet dhcp   # and this
<code>
* use `/etc/qemu-ifup` script to bring up your network:
</code>bash</p>

<h1>!/bin/sh</h1>

<p>echo &ldquo;Executing /etc/qemu-ifup&rdquo;
echo &ldquo;Bringing up $1 for bridged mode&hellip;&rdquo;
sudo /sbin/ifconfig $1 0.0.0.0 promisc up
echo &ldquo;Adding $1 to br0&hellip;&rdquo;
sudo /sbin/brctl addif br0 $1
sleep 2
```</p>

<p>Give executable permissions for this file:
<code>
sudo chmod +x /etc/qemu-ifup
</code></p>

<p>Restart networking services locally:
<code>
sudo service networking restart
</code></p>

<p>This should prepare you environment for tftp booting in qemu.</p>

<p><a id="ubuntu-issues"></a></p>

<h4>Ubuntu issues</h4>

<p>I had experienced few problems with my Ubuntu 12.04.</p>

<ul>
<li><p>First thing was defect that cause looping u-boot during emulation in
qemu-system-arm. I checked latest qemu and version delivered in distro
repository but qemu wasn&rsquo;t issue. I tried debug problem with gdb and qemu
<code>-s -S</code> switches and find out that u-boot crashes at <code>__udivsi3</code> instruction
in <code>serial_init</code>. I tried to google this issue but found only one comment
about this on <a href="http://balau82.wordpress.com/2010/04/12/booting-linux-with-u-boot-on-qemu-arm/">Balau blog</a>:
<blockquote><p>For anyone trying to reproduce this, at least on a recent Ubuntu host, you may need to pass “-cpu all” or “-cpu cortex-a8″ to qemu. The libgcc that gets linked to u-boot appears to be compiled with thumb2 instructions which are not implemented in the Versatile cpu. I don’t get any u-boot console output without this flag, and using gdb I can see that the cpu takes an exception during <code>__udivsi3()</code> called from serial_init().</p><footer><strong>[Grant Likely]</strong></footer></blockquote>
Problem is at least 2-years old and still occurs. Unfortunately Grant&rsquo;s tricks
didn&rsquo;t help. I move to toolchain built by my own and problem was fixed. So the
moral of the story is: DO NOT USE TOOLCHAIN PROVIDED BY UBUNTU at least in
12.04.</p></li>
<li><p>Second thing also involve a lot of debugging time and when I found workaround
it was accidentally. I saw that using procedure correct for Debian on Ubuntu I
was unable to obtain any packet inside U-Boot. Network traffic analysis show
that U-Boot correctly send DHCP discovery and server reply with DHCP offer,
but bootloader behaves like no packet was received.  Static configuration also
didn&rsquo;t work. Finally I get to information how to capture traffic from inside
of emulated setup (parameter <code>-net dump,file=/path/to/file.pcap</code> do the
thing). Surprisingly for some reason adding dump param fix problem and U-Boot
received DHCP Offer and ACK. I will try to narrow down this problem for
further reading please take a look <a href="http://lists.nongnu.org/archive/html/qemu-discuss/2013-05/msg00013.html">qemu</a>
and <a href="">u-boot</a> mailing list thread.</p></li>
</ul>


<p><a id="verify-qemu-with-tftp"></a></p>

<h4>Verify all components of Virtual Development Platform</h4>

<p>So right now we should have built <a href="/blog/2013/06/07/linux-kernel-for-embedded-system">kernel uImage</a>, <a href="/blog/2013/06/07/embedded-board-bootloader">U-Boot image</a>,
<a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#qemu-networking">configured qemu network</a> and <a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board/#setup-tftpd">tftp server</a>. With all this components we can
verify if our kernel booting on emulated <code>versatilepb</code>.</p>

<p>Run your qemu with network using U-Boot image as a kernel.
<code>bash
sudo qemu-system-arm -kernel /path/to/u-boot/u-boot -net nic,vlan=0 -net tap,vlan=0,ifname=tap0,script=/etc/qemu-ifup -nographic -M versatilepb
</code>
<em>NOTE</em>: We want to use u-boot file instead of u-boot.bin. First is ELF binary
image and second is raw binary. Raw binary image can be used with <code>-bios</code>
parameter for qemu. If you try to give raw binary as a kernel parameter it will result with error:
<code>
qemu: fatal: Trying to execute code outside RAM or ROM at 0x08000000
</code>
<em>NOTE 2</em>: We have to specify <code>versatilepb</code> machine. If we forget it we will get
error:
<code>
qemu: hardware error: integratorcm_read: Unimplemented offset 0x1e0000
</code></p>

<p>Right now we have u-boot booted. Let&rsquo;s set ip addresses to boot uImage from our
tftp server. For verification needs we don&rsquo;t want to <code>autoload</code> downloaded
image, so we disable this through environment variable.
<code>bash
setenv autoload no
dhcp
setenv serverip 192.168.1.2
setenv bootfile uImage
tftpboot
</code>
Set addresses according to your configuration. For some reason I was unable to
use u-boot <code>dhcp</code> feature. It assign me address that exist in the network.</p>

<p>We can take a close look on out downloaded image with <code>iminfo</code> command.
<code>tftpboot</code> and <code>iminfo</code> should looks like that:
```
VersatilePB # tftpboot
SMC91111: PHY auto-negotiate timed out
SMC91111: MAC 52:54:00:12:34:56
Using SMC91111-0 device
TFTP from server 10.0.2.15; our IP address is 10.0.2.16
Filename &lsquo;uImage&rsquo;.
Load address: 0x7fc0
Loading: #################################################################</p>

<pre><code>     #################################################################
     #################################################################
     #################################################################
     #################################################################
     ##############################################
     0 Bytes/s
</code></pre>

<p>done
Bytes transferred =
1895064 (1cea98 hex)
VersatilePB # iminfo</p>

<h2>Checking Image at</h2>

<p>00007fc0 &hellip;</p>

<pre><code>Legacy image found
Image Name:   Linux-3.9.0-rc8
Image Type:   ARM Linux Kernel Image (uncompressed)
Data Size:    1895000 Bytes = 1.8 MiB
Load Address: 00008000
Entry Point:  00008000
Verifying Checksum ... OK
</code></pre>

<p>```</p>

<p>So, that what we want to see. Pretty new kernel <code>3.9.0-rc8</code> compiled as ARM
image. We can try to boot it but we will end with kernel panic because lack of
filesystem.</p>

<p><em>NOTE 3</em>: If you want to see anything after booting this image with <code>bootm</code> you
have to pass to kernel additional boot argument with serial device that should
be used as a console. Before <code>bootm</code> set:
<code>
setenv bootargs console=ttyAMA0
</code>
You should get something similar to below log:
<code>
(...)
eth0: SMC91C11xFD (rev 1) at c89c8000 IRQ 57 [nowait]
eth0: Ethernet addr: 52:54:00:12:34:56
mousedev: PS/2 mouse device common for all mice
TCP: cubic registered
NET: Registered protocol family 17
VFP support v0.3: implementor 41 architecture 1 part 10 variant 9 rev 0
VFS: Cannot open root device "(null)" or unknown-block(0,0): error -6
Please append a correct "root=" boot option; here are the available partitions:
1f00           65536 mtdblock0  (driver?)
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
[&lt;c0018afc&gt;] (unwind_backtrace+0x0/0xf0) from [&lt;c027af8c&gt;] (panic+0x80/0x1d0)
[&lt;c027af8c&gt;] (panic+0x80/0x1d0) from [&lt;c0343c64&gt;] (mount_block_root+0x1a0/0x258)
[&lt;c0343c64&gt;] (mount_block_root+0x1a0/0x258) from [&lt;c0343f08&gt;] (mount_root+0xf0/0x118)
[&lt;c0343f08&gt;] (mount_root+0xf0/0x118) from [&lt;c0344090&gt;] (prepare_namespace+0x160/0x1b4)
[&lt;c0344090&gt;] (prepare_namespace+0x160/0x1b4) from [&lt;c03438ec&gt;] (kernel_init_freeable+0x168/0x1ac)
[&lt;c03438ec&gt;] (kernel_init_freeable+0x168/0x1ac) from [&lt;c027a074&gt;] (kernel_init+0x8/0xe4)
[&lt;c027a074&gt;] (kernel_init+0x8/0xe4) from [&lt;c0013df0&gt;] (ret_from_fork+0x14/0x24)
</code>
This is expected result.</p>

<p><a id="what-next"></a></p>

<h3>What next ?</h3>

<p>We happily built basic virtual development, what we need right now is some
<a href="/blog/2013/06/07/root-file-system-for-embedded-system">initial filesystem</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x4: Linux kernel for embedded system]]></title>
    <link href="http://pietrushnic.github.io/blog/2013/06/07/linux-kernel-for-embedded-system/"/>
    <updated>2013-06-07T10:33:00+02:00</updated>
    <id>http://pietrushnic.github.io/blog/2013/06/07/linux-kernel-for-embedded-system</id>
    <content type="html"><![CDATA[<h2>Table of contents</h2>

<ul>
<li><a href="/blog/2013/06/07/linux-kernel-for-embedded-system/#a-little-history">A little history</a></li>
<li><a href="/blog/2013/06/07/linux-kernel-for-embedded-system/#get-linux-and-build-it">Get linux and build it</a></li>
<li><a href="/blog/2013/06/07/linux-kernel-for-embedded-system/#kudos">Kudos</a></li>
</ul>


<p><a id="a-little-history"></a></p>

<h3>A little history</h3>

<p>Thinking about embedded linux probably leads to  first try of porting linux to
different architecture. I did google research (I know I should probably read
mailing list archive) and found that there were few attempt to port linux to
different platform. There is no clear information about which port of linux was
first. This is probably because many hackers didn&rsquo;t report their effort. Arguably
earliest out-of-tree version was probably for Acron A5000 (arm), Motorola 68000
(m68k) around Spring/Summer of 1994. I found also notes about SPARC port in
1993. Some sources also tells story about 1993 Amiga and Atari port. But first
port that get in to official linux tree was DEC Alpha.<a href="http://digital-domain.net/lug/unix-linux-history.html">[1]</a><a href="http://www.arm.linux.org.uk/docs/history.php">[2]</a></p>

<p>So linux is already 22 years old and first port start when it was 2-3 years old,
so we can assume it is mature enough to support most of non-x86 architectures.</p>

<p><a id="get-linux-and-build-it"></a></p>

<h3>Get linux and build it</h3>

<p>To deal with our <em>embedded</em> board we need operating system or some kind of
software that will allow us to use board features. Right now to boot system we
need at least kernel. So we have to prepare kernel for board of choice
<code>versatilepb</code>.</p>

<p>Let&rsquo;s start with cloning Linux repository:
<code>
git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
</code>
and configure kernel for <code>versatilepb</code>.
<code>
cd linux
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- versatile_defconfig
</code></p>

<p>It looks some feature is disabled in <code>versatile_defconfig</code>. I mean
<code>CONFIG_AEABI</code>. It specifies file format, data types, register usage and other
things. The main difference between EABI and ABI is that privileged instructions
are allowed in application code. More about EABI
<a href="http://en.wikipedia.org/wiki/Application_binary_interface#EABI">here</a>.
To enable this option run:
<code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- menuconfig
</code>
and go to:
<code>
Kernel Features -&gt; Use the ARM EABI to compile the kernel
</code>
We will also need DHCP and NFS support (CONFIG_IP_PNP_DHCP and CONFIG_ROOT_NFS).
First is <code>IP: DHCP support</code> and can be found under:
```
&ndash;> Networking support (NET [=y])
  &ndash;> Networking options</p>

<pre><code>-&gt; TCP/IP networking (INET [=y])
  -&gt; IP: kernel level autoconfiguration (IP_PNP [=y])
</code></pre>

<p><code>
Second is :
</code>
&ndash;> File systems
  &ndash;> Network File Systems (NETWORK_FILESYSTEMS [=y])<br/>
<code>
let's build image with U-Boot support.
</code>
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- uImage
```
We have kernel. How we can provide this kernel to our development environment ?
As I discuss in <a href="/blog/2013/06/07/embedded-board-bootloader">previous post</a> we
can use bare-metal qemu, but not with uImage kernel. This is special U-Boot
kernel, so easiest way will be using it with bootloader. We will figure out how
to do this in <a href="/blog/2013/06/07/qemu-network-configuration-and-tftp-for-virtual-development-board">next section</a>
about tftp and qemu network configuration.</p>

<p><strong>TODO</strong>: add picture of configuration in intro &ndash; vdb, link it here
Target configuration will consist on providing kernel through tftp server using U-Boot. Also
want to use NFS root filesystem to boot our small distro. As it is in real
development environment.</p>

<p><em>NOTE</em>: During compilation process you can encounter error like this:
<code>
(...)
  UIMAGE  arch/arm/boot/uImage
  "mkimage" command not found - U-Boot images will not be built
  make[1]: *** [arch/arm/boot/uImage] Error 1
  make: *** [uImage] Error 2
</code>
Of course it means that we need mkimage to create U-Boot image, so:
<code>
sudo apt-get install uboot-mkimage
</code>
<em>Update</em>: in Debian jessie/sid this package was replaced by <code>u-boot-tools</code>.</p>

<p>We have to use uImage special build because load and execute address differes
from board to board. If we will use vmlinux image then addresses should be
manually modified. So using uImage is easiest</p>

<p><a id="kudos"></a></p>

<h3>Kudos</h3>

<p>[1] <a href="http://digital-domain.net/lug/unix-linux-history.html">UNIX/Linux History</a></br>
[2] <a href="http://www.arm.linux.org.uk/docs/history.php">The History of ARM Linux</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[0x3: Embedded board bootloader]]></title>
    <link href="http://pietrushnic.github.io/blog/2013/06/07/embedded-board-bootloader/"/>
    <updated>2013-06-07T10:32:00+02:00</updated>
    <id>http://pietrushnic.github.io/blog/2013/06/07/embedded-board-bootloader</id>
    <content type="html"><![CDATA[<h2>Table of contents</h2>

<ul>
<li><a href="/blog/2013/06/07/embedded-board-bootloader/#what-is-bootloader">What is bootloader ?</a></li>
<li><a href="/blog/2013/06/07/embedded-board-bootloader/#why-we-need-bootloader">Why we need bootloader ?</a></li>
<li><a href="/blog/2013/06/07/embedded-board-bootloader/#which-bootloader">Which bootloader ?</a></li>
<li><a href="/blog/2013/06/07/embedded-board-bootloader/#what-is-versatilepb">What is versatilepb ?</a></li>
<li><a href="/blog/2013/06/07/embedded-board-bootloader/#compilation">Compilation</a></li>
<li><a href="/blog/2013/06/07/embedded-board-bootloader/#where-to-go-from-here">Where to go from here ?</a></li>
<li><a href="/blog/2013/06/07/embedded-board-bootloader/#kudos">Kudos</a></li>
</ul>


<p><a id="what-is-bootloader"></a></p>

<h3>What is bootloader ?</h3>

<p>It is a program written to bring up more complex code (eg. kernel).</p>

<p>On very simple system it can even not exist. Bootloader should prepare all
required hardware that kernel or different operating software will need at its
start point. It is hard to create cross platform bootloader because of variety
of system requirements.</p>

<p><a id="why-we-need-bootloader"></a></p>

<h3>Why we need bootloader ?</h3>

<p>The true is that we don&rsquo;t :) because we can simply pass kernel and initramfs as
parameters to QEMU, but it is not common practice for real development environment.<br/>
Usually bootloader is stripped in production environment where boot time is
crucial. Second thing, bootloader is useful to learn how real development
environment for embedded system works. From other side using bootloader we can
create single binary file that contain bootable embedded system, so we can run
it without giving multiple arguments at QEMU startup. I will try to keep in mind
idea about being as close to real development environment as possible.</p>

<p><a id="which-bootloader"></a></p>

<h3>Which bootloader ?</h3>

<p>There are many approaches to this problem. The most popular today is
<a href="http://www.denx.de/wiki/U-Boot">U-Boot</a> but there are alternatives like <a href="http://www.barebox.org/">The Barebox Bootloader</a>.
I will try to get to know them better in future. Right now I will use U-Boot as
Virtual Development Board bootloader to make the edit-compile-download-test cycle
similar to real world situation. So get the code:
<code>bash
git clone http://git.denx.de/u-boot.git
</code></p>

<p>U-Boot configuration depends on pair cpu-board. So right now we know that our
cpu will be some ARM but what exactly ? It depends on configuration we will use.
In most scenarios presented in Internet the <code>versatilepb</code> was used. We can also
think about running different boards.</p>

<p>What pros U-Boot gives us in the light of previous question <code>Why we need
bootloader ?</code>:
* simplified process of porting kernel, because low level stuff is handled by
U-Boot
* simplified testing environment in easy way you can grab different version of
  kernel with different version of initrd and test it</p>

<p><a id="what-is-versatilepb"></a></p>

<h3>What is versatilepb ?</h3>

<p>According to <a href="http://www.arm.com/products/tools/development-boards/versatile/index.php">this page</a>
versatile is highly modular, feature-rich range of development board. <code>pb</code>
means <code>Platform Baseboard</code> integrated, standalone development system with fixed
CPU. But this is only corporate babble :)</p>

<p>QEMU shows <code>versatilepb</code> as Versatile/PB
(<a href="http://www.arm.com/products/processors/classic/arm9/arm926.php">ARM926EJ-S</a>).</p>

<p><a id="compilation"></a></p>

<h3>Compilation</h3>

<p>For <code>Emdebian</code> cross-toolchain:
<code>bash
cd u-boot
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi- versatilepb_config
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabi-
</code></p>

<p><em>Note</em>: If you wonder what is the convention for cross-toolchain prefix:
<code>
[arch]-[vendor]-[os]-[abi]
</code>
<code>Emdebian</code> striped vendor probably to keep name short, but for example
<code>Corsstool-NG</code> follow convetion and calls toolchain like
<code>arm-unknown-linux-gnueabi-</code>.</p>

<p><a id="where-to-go-from-here"></a></p>

<h3>Where to go from here ?</h3>

<p><a href="/blog/2013/06/07/linux-kernel-for-embedded-system">Next step</a> will be kernel compilation for our virtual <code>versatilepb</code> board.</p>

<p><a id="kudos"></a></p>

<h3>Kudos</h3>

<p>[1] <a href="http://www.linuxfordevices.com/c/a/Linux-For-Devices-Articles/Introduction-to-Das-UBoot-the-universal-open-source-bootloader/">Introduction to Das U-Boot, the universal open source bootloader</a></br>
[2] <a href="http://www.denx.de/wiki/U-Boot">U-Boot</a></br>
[3] <a href="http://forum.xda-developers.com/showthread.php?t=2201146">U-boot for the multi-boot support</a></br>
[4] <a href="http://balau82.wordpress.com/2010/04/12/booting-linux-with-u-boot-on-qemu-arm/">Booting Linux with U-Boot on QEMU ARM</a></br>
[5] <a href="http://wiki.osdev.org/Bootloader">Bootloader</a></br></p>
]]></content>
  </entry>
  
</feed>
